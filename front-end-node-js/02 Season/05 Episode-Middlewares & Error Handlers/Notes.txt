=> What is Middleware?
   Middleware is a function in Express that executes between the incoming request and the final response. It has access 
   to req, res, and next, and it can modify the request, send a response, or pass control to the next middleware.
   Express internally works as a chain of middleware functions executed sequentially.

=> Why do we use next()?
   next() passes control to the next middleware function in the stack. Without calling next(), the request will hang 
   because Express won’t know how to continue processing. It ensures the request–response cycle continues.

=> Can we send multiple responses for one request?
   No. Only one response can be sent per request. Sending multiple responses causes the “Cannot set headers after they 
   are sent” error because HTTP allows only one response per request.

=> How to create error-handling middleware?
   Error-handling middleware is created by defining a function with four parameters: (err, req, res, next). Express 
   automatically recognizes it as an error handler when next(err) is called.
   Example:
   app.use((err, req, res, next) => {
     res.status(500).send(err.message)
   })

=> Why must error middleware be last?
   Because Express executes middleware in the order they are registered. If the error handler is placed before other routes, it won’t catch errors from them. Placing it last ensures it can handle errors from all previous middleware and routes.

=> Explain middleware flow in one sentence:
   A request enters the server, passes through a sequence of middleware functions using next(), and finally one middleware sends the response or an error handler handles failures.

=> How Express REALLY works internally?
   Incoming Request
         ↓
   Middleware 1
         ↓ next()
   Middleware 2
         ↓ next()
   Middleware 3
         ↓ res.send()
   Response ends

=> Difference between app.use and app.all:
   app.use() is for middleware and prefix matching, while app.all() is for route handling and exact path matching for all HTTP methods.

   # app.use():
     Used to register middleware functions.
     Behavior
     - Matches all HTTP methods (GET, POST, PUT, DELETE…)
     - Matches prefix paths
     - Mostly used for middleware logic
     Example:
     app.use("/user", (req,res,next)=>{
        console.log("middleware")
        next()
     })
     Matches:
     - /user
     - /user/1
     - /user/profile
     - /user/anything

   # app.all():
     Used to handle all HTTP methods for a specific route.
     Behavior
     - Matches all HTTP methods
     - Matches exact route only
     - Used for route handling (not general middleware)
     Matches:
     - GET /user
     - POST /user
     - PUT /user
     - DELETE /user

=> Visual Comparison:
   Feature	     app.use()	         app.all()
   Purpose	     Middleware	      Route handler
   Methods	     All	               All
   Path match	  Prefix	            Exact
   Needs next()  Usually yes	      Usually no
   Common use	  auth, logs	      handle all methods of route

=> Why we NEED middleware?
   Middleware helps process requests in a modular and reusable way. It allows us to separate concerns like logging, authentication, validation, and error handling before reaching the route logic. This keeps the code clean, avoids duplication, and makes the application scalable and maintainable.
   
   Code Reusability:
   Write once, use everywhere.
   Example:
   - auth
   - logging
   - error handling

   Separation of Concerns:
   Each function does ONE thing.
   Bad:
   route → auth + log + business + response
   Good:
   auth → log → controller → response

   Cleaner Routes:
   Routes should contain only business logic.
   Not 50 lines of checks.

   Centralized Control:
   Easy to:
   - add security
   - add rate limit
   - add headers
   - add monitoring

   Error Handling:
   Catch errors globally.
   Instead of:
   try/catch in every route
   Just:
   app.use(errorHandler)

